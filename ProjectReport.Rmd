---
title: "Modelling Architectures Underlying Financial Pricing Problems"

date: "`r Sys.Date()`"

author: "Patrick Reidy"

affiliation: "School of Mathematical Sciences, University College Cork"

email: "120442916@umail.ucc.ie"

output: 
  bookdown::pdf_document2:
    fig_crop: no
    keep_tex: TRUE
    extra_dependencies: ["subfig", "tikz"]
  author:
  - name: "Patrick Reidy"
    affiliation: "School of Mathematical Sciences, University College Cork"
    email: "120442916@umail.ucc.ie"
    
header-includes:
  - \usepackage{titling}
  - \pretitle{\begin{center}
    \includegraphics[width=4in,height=2in]{data/figures/University_College_Cork_logo.png}\LARGE\}
  - \posttitle{\end{center}}
  - \usepackage{tikz}
  - \usetikzlibrary{positioning, arrows.meta, shapes.geometric}
  - \usepackage{amsmath}
  


editor_options: 
  chunk_output_type: inline
  
bibliography: references/fyp_references.bib
csl: https://www.zotero.org/styles/ieee
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

library(OpenML)
library(tidyverse)
library(tidymodels)
library(raster)
library(ggplot2)
library(gridExtra)
library(knitr)
library(kableExtra)
library(keras)

source("R/functions/source_functions.R")
source_functions()
set_global_variables(verbose = 0,
                     source = TRUE)

cars_orig <- OpenML::getOMLDataSet(data.id = 41214)$data
```

\newpage

\listoffigures

\listoftables

# Abstract

## Problem Statement

## Indication of Methodology

## Main Findings

## Principal Conclusion

# Introduction

The field of insurance pricing has witnessed a significant evolution in modelling techniques over the years, with a transition from traditional regression methods to more sophisticated models such as Generalized Linear Models (GLMs) and, most recently, Deep Learning (DL) models.

Linear regression, as the earliest and simplest form of modelling [@su_2012_linear], has been used in a variety of predictive applications due to its ease of interpretation and implementation. However, it struggled to handle the complexities of higher-order applications, such as the representation of non-linear relationships. This is particularly problematic in the context of insurance data, where the outcome is heavily influenced by complex interactions between multiple fields and attributes. Consequently, Generalized Linear Models emerged as a significant advancement, offering a more flexible framework that accommodated various distribution families and data types. GLMs excel in modelling discrete and continuous outcomes while retaining interpretability, making them the go-to choice for many years.

Deep Learning models have recently taken industries across the world by storm, not least the insurance industry, ushering in a new era of predictive accuracy. Neural networks, with their multilayered architecture, can capture intricate patterns in massive datasets, including high-dimensional data, unstructured data, and temporal data. DL models have demonstrated remarkable capabilities in feature extraction, non-linear relationship modelling, and predictive accuracy. They are capable of handling diverse data types such as images, text, and tabular data, which is particularly valuable in the age of big data. These advantages extend to the world of insurance pricing, where their potential remains yet to be completely realised.*TODO: expand!*

The transition from GLMs to Deep Learning is not without its challenges. While DL models excel in predictive performance, they often sacrifice interpretability, which is a crucial requirement in the insurance industry for regulatory compliance and trustworthiness. Additionally, the capabilities of unsupervised learning has been at times overestimated, with many foregoing vital data preprocessing and investigation in the excitement of early demonstrations of these models' performance*TODO: expand!*. Ensuring model fairness *??, expand* and avoiding bias in DL models remains an active area of research, as it is crucial for ethical underwriting and legal compliance. One method to address these concerns is to improve the explainability of these models, or bridge the gap in performance between traditional GLMs and DL models.

## Background

### Linear Regression

Simple regression models are a statistical method to describe the relationship between two variables. They are made up of two components: the Systematic component, and the random component. In the simplest case they take the form:

$$Y = \beta_0 + \beta_1X + \epsilon$$

Where:

-   $Y$ is the dependent or response variable

-   $X$ is the independent or predictor variable

-   $\beta_0$ is the intercept, representing the value of the response when $X = 0$

-   $\beta_1$ is the coefficient that determines the slope and hence the relationship between $X$ and $Y$

-   $\epsilon$ is the error term or noise, representing unexplained variability in the model

The random component here is the $\epsilon$ term, often assumed to be normally distributed, whereas the systematic component is the $\beta_0 + \beta_1X$

This approach can be expanded to incorporate multiple predictor variables and as such takes the form

$$Y = \beta_0 + (\Sigma_{i=1}^p \beta_iX_i) + \epsilon$$

Where:

-   $Y$, $\beta_0$, and $\epsilon$ are the same as before

-   $p$ is the number of predictor variables

-   $X_i, \ i =(1,...,p)$ are the multiple predictor variables

-   $\beta_i, \ i = (1,...,p)$ are the coefficients that represent the relationship between $Y$ and the $X_i$ 's

*TODO: Expand on each of the above, Underlying assumptions, link between linear regression and GLM*

Underlying assumptions: normally distributed error, least squares estimate

### GLMs

With the advent of Generalised Linear Models discussed by Nelder and Wedderburn[@nelder_1972_generalized], the technique of regression modelling was expanded to yield more robust and effective models. The introduction of a link function is used to capture the non-normal distribution of the data. These are defined as:

$$g(\mu) = \beta_0 + \beta_1X_1 +...+ \beta_pX_p$$

Where:

-   $p$ is the number of predictor variables incorporated into the model

-   $\mu$ is the response variable

-   $g: \mathbb{R} \to \mathbb{R}$ is the link function that relates the expected value of $\mu$ to the linear combination of the predictors

-   $X_1,..., X_p$ are the predictor variables

-   $\beta_1,..., \beta_p$ are the coefficients that determine the slope depending on the values of $X_1,..., X_p$

-   $\beta_0$ represents again the intercept, or the value returned when $X_1,..., X_p$ are all equal to zero

```{=html}
<!--# 
o Establishing a territory
  -> Claiming centrality
  -> Making topic generalisations
  -> Reviewing items of previous research
  
  "In the past decade much research has focused on..."

o Establishing a niche
  -> Counter-claiming
  -> Indicating a gap
  -> Question Raising
  -> Continuing a tradition
  
  "It remains unclear why..."

o Occupying the niche
  -> Outlining purposes
  -> Announcing principal findings
  -> Indicating Structure
  
  "The purpose of this study was to..."
-->
```
### Neural Networks

#### Attempt 1

If we recall the formula for the GLM:

$$Y = \beta_0 + \beta_1X_1 + \beta_2X_2 + \ldots + \beta_pX_p + \epsilon$$

We can also write this in matrix notation

$$
Y = \beta_0 + 
\begin{bmatrix} \beta_1, \ldots, \beta_p\end{bmatrix}
\begin{bmatrix} X_1 \ \vdots \ X_p\end{bmatrix}
$$

When looking at neural networks, we see a familiar form for a simple network with no hidden layers (these will be discussed further later). A neural network typically takes the form:

$$
Y = \begin{bmatrix} W_{11} & \ldots & W_{1p} \ 
                    \vdots & \ddots & \vdots \
                    W_{q1} & \ldots & W_{qp}\end{bmatrix} 
    \begin{bmatrix} X_1 \ \vdots \ X_p\end{bmatrix}
$$

There are two key differences between this form and the previous:

-   There is no intercept in the NN formula, meaning the response is not necessarily being made relative to some base case

-   Rather than a row vector of coefficients, we instead use a $n\times p$ matrix of weights. This is especially useful in capturing relationships between variables. Of course the result of this is no longer a single value, but a vector of length $q$ which for now is arbitrarily chosen.

In order to return a single value as desired, we must again multiply the results of this equation by a row vector of length $q$.

$$
Y = \begin{bmatrix}\begin{bmatrix} W_{1,11} & \ldots & W_{2,1p} \ 
                    \vdots & \ddots & \vdots \
                    W_{1,q1} & \ldots & W_{1,qp}\end{bmatrix} 
    \begin{bmatrix} X_1 \ \vdots \ X_p\end{bmatrix}\end{bmatrix}
    \begin{bmatrix} W_{2,1} & \ldots & W_{2,q}\end{bmatrix}
$$

Here we now have two matrices of weights, $W_1$ and $W_2$ which results in a scalar output $Y$.

#### Attempt 2

If we recall our GLM formula of

$$log(\mu) = \beta_0 + \beta_1X_1 +...+ \beta_pX_p$$

We can rewrite this in matrix notation as

$$
log(\mu) = \beta_0 + 
\begin{bmatrix} \beta_1, \ldots, \beta_p\end{bmatrix}
\begin{bmatrix} X_1 \ \vdots \ X_p\end{bmatrix}
$$

Representing a full model of $p$ independent variables. However, for fitting a saturated model including all possible interactions, very quickly our number of variables grows to an unmanageable size. Computability, memory availability, and interpretability will all suffer. However, we can extend our set of coefficients into a matrix with an arbitrary amount of rows, say $q$ which each represent some relationship over all predictors. This will result in a formula that looks like

$$
           \begin{bmatrix} W_{11} & \ldots & W_{1p} \ 
                    \vdots & \ddots & \vdots \
                    W_{q1} & \ldots & W_{qp}\end{bmatrix} 
           \begin{bmatrix} X_1 \ \vdots \ X_p\end{bmatrix} 
         = \begin{bmatrix} H_1 & \ldots & H_q\end{bmatrix} 
$$

This results in a vector of length $q$ which represents $q$ relationships from the model. Of course, as we desire a scalar output similar to how a GLM would produce, we would then need to multiply this by a column vector of length $q$ $$
\hat{Y} = \begin{bmatrix}\begin{bmatrix} W_{1,11} & \ldots & W_{2,1p} \ 
                    \vdots & \ddots & \vdots \
                    W_{1,q1} & \ldots & W_{1,qp}\end{bmatrix} 
    \begin{bmatrix} X_1 \ \vdots \ X_p\end{bmatrix}\end{bmatrix}
    \begin{bmatrix} W_{2,1} & \ldots & W_{2,q}\end{bmatrix}
$$

Where $\hat{Y}$ is our new scalar output and instead of one matrix of coefficients $W$ we have $W_1$ and $W_2$. It may also at this stage be helpful to make an adjustment similar to what we do for interpreting GLMs where

$$log(\mu) = \beta_0 + \beta_1X_1 +...+ \beta_pX_p$$

And after getting the exponential of both sides, this becomes equivalent to

$$\mu = exp(\beta_0 + \beta_1X_1 +...+ \beta_pX_p)$$

And applying this to our matrix notation we now get

$$
\hat{Y} = exp\left(\begin{bmatrix}\begin{bmatrix} W_{1,11} & \ldots & W_{2,1p} \ 
                    \vdots & \ddots & \vdots \
                    W_{1,q1} & \ldots & W_{1,qp}\end{bmatrix} 
    \begin{bmatrix} X_1 \ \vdots \ X_p\end{bmatrix}\end{bmatrix}
    \begin{bmatrix} W_{2,1} & \ldots & W_{2,q}\end{bmatrix}\right)
$$ It is clear that with the nesting of these processes, the architecture becomes very difficult to understand. We can write this in a more sequential pattern as following:

$$
\hat{Y} = \begin{bmatrix} W_{1,11} & \ldots & W_{2,1p} \ 
                    \vdots & \ddots & \vdots \
                    W_{1,q1} & \ldots & W_{1,qp}\end{bmatrix} 
          \begin{bmatrix} X_1 \ \vdots \ X_p\end{bmatrix}
        = \begin{bmatrix} H_1 & \ldots & H_q\end{bmatrix} 
\Rightarrow
          \begin{bmatrix} H_1 & \ldots & H_q\end{bmatrix}
   \times \begin{bmatrix} W_{2,1} & \ldots & W_{2,q}\end{bmatrix}
\Rightarrow
    exp()
$$

This can be made even clearer visually by representing vectors and matrices as nodes in a network, and producing a computation graph.

```{r, simpleCompGraph, results='asis', echo = FALSE}
cat(c(
  "
  \\begin{figure}
    \\centering
      \\begin{tikzpicture}[>=stealth, node distance=1.5cm, every node/.style={scale=0.8}]
      % Input layer
      \\node[circle, draw, fill=yellow!20] (X) at (0,-1) {$X$};
      \\node[circle, draw, fill=blue!20] (W1) at (0,-2) {$W_1$};
      
      \\node[circle, draw, fill=green!20] (star1) at (1,-1) {$*$};
      
      
      % Labels
      \\node[above=0.5cm of X] {Input Layer};
      
      % Connect Nodes
      \\draw[->] (X) -- (star1);
      \\draw[->] (W1) -- (star1);
      
      
      
      % First Hidden Layer
      \\node[circle, draw, fill=blue!20] (W2) at (2,-2) {$W_2$};
      
      \\node[circle, draw, fill=green!20] (star2) at (3,-1) {$*$};
      
      
      % Connect Nodes
      \\draw[->] (star1) -- (star2);
      \\draw[->] (W2) -- (star2);
      
      
      
      
      % Final Layer
      \\node[circle, draw, fill=green!20] (link) at (4,-1) {$exp$};
      \\node[circle, draw, fill=yellow!20] (output) at (5,-1) {$\\hat{y}$};
      
      % Connect Nodes
      \\draw[->] (star2) -- (link);
      \\draw[->] (link) -- (output);
    
    \\end{tikzpicture}
    \\caption{Computation Graph of Neural Network}
    \\label{fig:neural_network_computation_graph}
  \\end{figure}
  "))
```

# Literature Review

# Methodology

```{=html}
<!--
"The data used for this study were collected by..."
-->
```
## Data Collection

This study is carried out using the French motor third partly liability claims frequency data (FreMTPL2freq) available through CASdatasets [@CASdatasets].

```{r tabHead, echo=FALSE, include=TRUE, paged.print=TRUE}
head(cars_orig) %>%
  kable(
    format = "latex", booktabs = TRUE,
    caption = "Structure of the FreMTPL2freq Dataset",
    row.names = FALSE
  ) %>%
  kable_styling(latex_options = "scale_down") %>%
  kable_styling(latex_options = "HOLD_position") %>% 
  kable_styling(latex_options = "striped")
```

The description of the data as outlined in the documentation is as follows:

*"Context: In the dataset freMTPL2freq risk features and claim numbers were collected for 677,991 motor third-part liability policies (observed on a year). Content freMTPL2freq contains 11 columns*

-   *IDpol: The policy ID (used to link with the claims dataset).*

-   *ClaimNb: Number of claims during the exposure period.* This is the variable to be predicted

-   *Exposure: The exposure period.*

-   *Area: The area code.* Six distinct area codes from A to F.

-   *VehPower: The power of the car (ordered categorical).*

-   *VehAge: The vehicle age, in years.*

-   *DrivAge: The driver age, in years (in France, people can drive a car at 18).*

-   *BonusMalus: Bonus/malus, between 50 and 350: 100 means malus in France.*

-   *VehBrand: The car brand (unknown categories).*

-   *VehGas: The car gas, Diesel or regular.*

-   *Density: The density of inhabitants (number of inhabitants per km2) in the city in which the driver of the car lives.*

-   *Region: The policy regions in France (based on a standard French classification) "*

```{r tableSum, echo=FALSE, include=TRUE, paged.print=TRUE}
cars_orig %>% 
  mutate(VehGas = as.factor(VehGas)) %>% 
  dplyr::select(-IDpol, -where(is.factor)) %>% 
  summary() %>% 
  knitr::kable(format = "latex", booktabs = TRUE,
               caption = "Summary of Variables in Data") %>%
  kable_styling(latex_options = "scale_down") %>%
  kable_styling(latex_options = "HOLD_position") %>% 
  kable_styling(latex_options = "striped")
```

## Data Analysis

```{r setup_fig, echo=FALSE}

wd <- file.path("C:/Users/patos/Documents/ST4092_120442916")
dsn <- file.path(wd, "data/input/shapefile")
```

Before investigating the performance of the models, we carry out a number of investigations regarding the structure and behaviour of the data. This is important in identifying which methods to use, issues to address and results to expect.

*Should first step be investigating e.g. cor matrix, i.e. dataset as a whole?*

As ClaimNb is the response variable it is no doubt the most important variable to understand and the first variable we investigate. Figure \@ref(fig:fig_cor)

*Discuss each plot in turn and insights yielded, Motivation behind each plot*

*Histogram of every factor vs ClaimNb - Area, Vehpower, VehAge, VehBrand, VehGas, Region* *Scatterplot of every numeric vs ClaimNb - Exposure, DrivAge, Density* *Map of every variable*

See Figure \@ref(fig:figHist-1)

See Figure \@ref(fig:figHist-2)

See Figure \@ref(fig:figHist-3)

See Figure \@ref(fig:figHist-4)

\newpage

<center>

<center>

```{r figCor, echo=FALSE, fig.cap = "Correlation Heatmap of Features", fig.path = "data/figures/"}
par(mfrow = c(1, 1))
cars_orig %>%
  mutate(across(where(is.factor), ~ as.numeric(unclass(.)))) %>%
  mutate(VehGas = as.numeric(VehGas == "Diesel")) %>%
  dplyr::select(-IDpol) %>% 
  cor() %>% 
  heatmap(keep.dendro = FALSE)
```

\newpage

</center>

```{r figBox, echo = FALSE, include = TRUE, fig.path = "data/figures/", fig.cap = "Boxplots of Numerical Variables", fig.subcap = c("ClaimNb", "VehPower", "VehAge", "DrivAge", "Exposure"), out.width="20%", fig.ncol=5}

# 
# ggplot(cars_orig, aes(x = ClaimNb)) +
#   geom_boxplot(fill = "blue", color = "black", notch = TRUE, notch_width = 0.2) +
#   coord_flip()
# 
# ggplot(cars_orig, aes(x = VehPower)) +
#   geom_boxplot(fill = "green", color = "black", notch = TRUE, notchwidth = 0.2) +
#   coord_flip()
# 
# ggplot(cars_orig, aes(x = VehAge)) +
#   geom_boxplot(fill = "red", color = "black") +
#   stat_boxplot(geom='errorbar', width = 0.2) +
#   coord_flip()
# 
# ggplot(cars_orig, aes(x = DrivAge)) +
#   geom_boxplot(fill = "orange", color = "black") +
#   stat_boxplot(geom='errorbar') +
#   coord_flip()
# 
# ggplot(cars_orig, aes(x = Exposure)) +
#   geom_boxplot(fill = "purple", color = "black") +
#   stat_boxplot(geom='errorbar') +
#   coord_flip()

boxplot(cars_orig$ClaimNb, col = "blue")
boxplot(cars_orig$VehPower, col = "green")
boxplot(cars_orig$VehAge, col = "red")
boxplot(cars_orig$DrivAge, col = "orange")
boxplot(cars_orig$Exposure, col = "purple")

```

```{r figHist, echo = FALSE, include = TRUE, fig.path = "data/figures/", fig.cap = "Histograms of Numerical Variables", fig.subcap = c("ClaimNb", "VehPower", "VehAge", "DrivAge", "Exposure"), out.width="20%", fig.ncol=5, out.height="100%"}

ggplot(cars_orig, aes(x = ClaimNb)) +
  geom_histogram(binwidth = 1, fill = "blue", color = "black") 

ggplot(cars_orig, aes(x = VehPower)) +
  geom_histogram(binwidth = 1, fill = "green", color = "black") 

ggplot(cars_orig, aes(x = VehAge)) +
  geom_histogram(binwidth = 1, fill = "red", color = "black") 

ggplot(cars_orig, aes(x = DrivAge)) +
  geom_histogram(binwidth = 1, fill = "orange", color = "black")

ggplot(cars_orig, aes(x = Exposure)) +
  geom_histogram(binwidth = 1/12, fill = "purple", color = "black")
```

\newpage

## Modelling

### GLMs

```{r glmSetup, include=TRUE, echo = FALSE}
# Get dataframe and split
cars_split <- cars_orig %>% 
  dplyr::select(-IDpol) %>% 
  dplyr::select(where(is.factor), everything()) %>% 
  initial_split(prop = 0.8)
train <- training(cars_split)
test <- testing(cars_split)
```

Using the basic stats \@[@stats-3] implementation of GLMs, one can fit a model with the following:

```{r glmFit, include  = TRUE, echo=TRUE}
glm1 <- glm(ClaimNb ~ ., data = train, family = poisson(link=log), offset = Exposure)
```

Yielding:

```{r glmSummaryCoef, include = TRUE, echo = FALSE}
glmSum <- summary(glm1)

summary(glm1)$coefficients %>% 
  as_tibble() %>% 
  mutate(
    " " = rownames(glmSum$coefficients),
    Significance = case_when(
    `Pr(>|z|)` == 0 ~ "***",
    `Pr(>|z|)` < 0.001 ~ "**",
    `Pr(>|z|)` < 0.01 ~ "*",
    `Pr(>|z|)` < 0.05 ~ ".",
    .default = " "    
  )) %>% 
  relocate(" ", .before = everything()) %>% 
  kable(
    format = "latex", booktabs = TRUE,
    caption = "Coefficients of fitted GLM",
    row.names = TRUE
  ) %>%
  kable_styling(latex_options = "HOLD_position") %>% 
  kable_styling(latex_options = "striped") %>% 
  pack_rows(
    index = c(
      " " = 1,
      "Area" = 5, 
      "VehBrand" = 10, 
      "Region" = 21, 
      "Numeric" = 7
    )
  )


```

```{r glmSumDetails, include = TRUE, echo = FALSE}

cat(
  "     Null Deviance:", glmSum$null.deviance,  "on", glmSum$df.null, "degrees of freedom\n",
  "Residual Deviance:", glmSum$deviance, "on", glmSum$df.residual, "degrees of freedom\n",
  "AIC:", glmSum$aic,
  "\n\n",
  "Number of Fisher Scoring iterations", glmSum$iter
  )
```

-   Where: “ClaimNb \~ .”: is the formula, signifying ClaimNb as the response variable and including all other variables as predictors

-   “train” is the training set

-   “family” is defined as poisson using log as the link function

Alternatively for more robust feature selection one can use backwards elimination

```{r glmBackElim, include = TRUE, echo = TRUE}
if (global_variables$source == TRUE) {
  backward_elimination <- get_backward_elimination("object")
} else {
  backward_elimination <- get_backward_elimination("run")
}
```

```{r glmBackSummaryCoef, include = TRUE, echo = FALSE}
# Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
glmBackElimSum <- summary(backward_elimination)

glmBackElimSum$coefficients %>% 
  as_tibble() %>% 
  mutate(
    " " = rownames(glmBackElimSum$coefficients),
    Significance = case_when(
    `Pr(>|z|)` == 0 ~ "***",
    `Pr(>|z|)` < 0.001 ~ "**",
    `Pr(>|z|)` < 0.01 ~ "*",
    `Pr(>|z|)` < 0.05 ~ ".",
    .default = " "    
  )) %>% 
  relocate(" ", .before = everything()) %>% 
  kable(
    format = "latex", booktabs = TRUE,
    caption = "Coefficients of GLM with backwards elimination",
    row.names = TRUE
  ) %>%
  kable_styling(latex_options = "HOLD_position") %>% 
  kable_styling(latex_options = "striped") %>% 
  pack_rows(
    index = c(
      " " = 1,
      "Area" = 5, 
      "VehBrand" = 10, 
      "Region" = 21, 
      "Numeric" = 6
    )
  )
```

```{r glmBackElimSumDetails, echo = FALSE, include = TRUE}
cat(
  "     Null Deviance:", glmBackElimSum$null.deviance,  "on", glmBackElimSum$df.null, "degrees of freedom\n",
  "Residual Deviance:", glmBackElimSum$deviance, "on", glmBackElimSum$df.residual, "degrees of freedom\n",
  "AIC:", glmBackElimSum$aic,
  "\n\n",
  "Number of Fisher Scoring iterations", glmBackElimSum$iter
  )

```

This is the familiar output of a the summary of a GLM, with the intercept, standard error and significance level of each predictor outlined. It can be seen that the categorical predictors have been split into dummy variables in the cases of Region, VehBrand, and Area. Metrics such as Deviance and AIC for the model as a whole can be seen underneath, alternatively we can evaluate performance with other metrics as seen below:

```{r glmMetrics, echo = FALSE, include=TRUE}
predictions <- predict(glm1, newdata = test, type = "response") %>% 
  as_tibble() %>% 
  mutate(index = seq(nrow(test)))

val_data <- test %>% 
  mutate(index = seq(nrow(test))) %>% 
  left_join(predictions, join_by(index))

yardstick::metrics(data = val_data, truth = ClaimNb, estimate = value) %>% 
  knitr::kable(format = "latex", booktabs = TRUE,
    caption = "Metrics of GLM Predictions on Validation Data") %>% 
  kable_styling(latex_options = "HOLD_position") %>% 
  kable_styling(latex_options = "striped") 

```

We can also look at a selection of predictions made from the resulting model:

```{r glmPredictions, include = TRUE, echo = FALSE, out.width = "100%", paged.print = TRUE}

head(val_data) %>% 
  dplyr::select(-index) %>% 
  relocate(ClaimNb, .before = value) %>% 
  mutate(Prediction = value) %>% 
  kable(format = "latex", booktabs = TRUE,
    caption = "Predictions from GLM on testing data") %>% 
  kable_styling(latex_options = "scale_down") %>% 
  kable_styling(latex_options = "striped") %>% 
  kable_styling(latex_options = "HOLD_position") %>%
  column_spec(11:12, bold  = TRUE) 
```

### Neural Networks

```{r nnSetup, include = TRUE, echo = FALSE}
log_info("Preprocess data")
df.n <- cars_orig %>% 
  dplyr::select(where(is.numeric)) %>% 
  mutate(across(c(where(is.numeric), -IDpol, -ClaimNb), ~ scale_col(.)))

df <- cars_orig %>% 
  mutate(ClaimNb = as.integer(ClaimNb)) %>% 
  dplyr::select(c(IDpol, !where(is.numeric))) %>% 
  mutate(VehGas = as.integer(VehGas == "Diesel")) %>% 
  left_join(df.n, join_by(IDpol)) %>% 
  dplyr::select(-IDpol)

## Create Recipe ---------------------------------------------------------------
recipe <- recipe(ClaimNb ~ ., data = df) %>%
  step_dummy(all_factor())

## Bake Data -------------------------------------------------------------------
preprocessed_data <- prep(recipe, training = df, retain = TRUE)
baked_data <- bake(preprocessed_data, new_data = NULL)

## Split Data ------------------------------------------------------------------
log_info("Test/train split")
indices <- sample(1:nrow(df), 0.8 * nrow(df))
train_data <- baked_data[indices, ] 
test_data <- baked_data[-indices, ] 

x_train <- train_data %>% dplyr::select(-ClaimNb)
x_test <- test_data %>% dplyr::select(-ClaimNb) %>% as.matrix()

y_train <- train_data$ClaimNb
y_test <- test_data$ClaimNb
```

```{r nnTune, include = TRUE, echo = FALSE}
# Define tuning grid
t_batchsize <- c(512,1024)
t_epochs <- c(30,50)
t_act_final <- c("softplus", "exponential")
t_lr <- c(0.01,0.001)

t_hidden_nodes <- c(16,32)
t_hidden_act <- c("relu", "tanh")

tune_grid <- expand.grid(
  batchsize = t_batchsize, 
  epochs = t_epochs, 
  final_act  = t_act_final, 
  learn_rate = t_lr,
  t_hidden_act1 = t_hidden_act, t_hidden_nodes1 = t_hidden_nodes,
  t_hidden_act2 = t_hidden_act, t_hidden_nodes2 = t_hidden_nodes)
```

```{r nnFit, echo = FALSE}
# Get list of fits from tuning
if (global_variables$source == TRUE) {
  model_list <- readRDS("data/objects/model_list.rds")
}

# Select best fit based on mse
best_fit <- get_best_fit(model_list, tune_grid)

# Fit best model
if (global_variables$source == TRUE) {
  best_model <- readRDS("data/objects/best_model.rds")
} else {
  best_model <- fit_keras_poisson(
    x_train,
    y_train,
    nodes = c(best_fit$t_hidden_nodes1, best_fit$t_hidden_nodes2),
    batchsize = best_fit$batchsize,
    n_epochs = best_fit$epochs,
    act_funs = c(best_fit$t_hidden_act1, 
                 best_fit$t_hidden_act2, 
                 best_fit$final_act),
    lr = best_fit$learn_rate,
    verbose = 0)
}
```

```{r nnMetrics, include = TRUE, echo = FALSE}
#Collect Metrics
metrics.df <- data.frame(
  matrix(rep(numeric(256), 5),
    ncol = 5,
    dimnames = list(
      seq_len(256),
      c("index", "loss", "mse", "val_loss", "val_mse")
    )
  )
) %>% 
  head() %>% 
  kable(
    format = "latex", booktabs = TRUE,
    caption = "Model Tuning Results",
    row.names = FALSE
  ) %>%
  kable_styling(latex_options = "scale_down") %>%
  kable_styling(latex_options = "HOLD_position") %>% 
  kable_styling(latex_options = "striped")
  
```

Below we can see the architecture of the neural network

```{r, nnFigNetwork, results='asis', echo=FALSE}
cat(get_network_tex(
    n_input = best_model$model$layers[[1]]$input_shape[[2]],
    n_hidden1 = best_model$model$layers[[2]]$input_shape[[2]],
    n_hidden2 = best_model$model$layers[[3]]$input_shape[[2]]))
```

Below we can see the computation graph of the neural network

```{r, nnCompGraph, results='asis', echo=FALSE}
cat(get_computation_graph_tex(
  act_funs = as.character(c(best_fit$t_hidden_act1,
                            best_fit$t_hidden_act2,
                            "exp"))))

```

## Results

# Discussion

## Introduction

```{=html}
<!--
o Review findings
o Discuss outcomes
o Stake a claim

"The findings of this study clearly show that..."
-->
```
## Evaluation

```{=html}
<!--
o Analyse
o Offer explanations
o Reference the literature
o State implications

"One explanation for..."
-->
```
## Conclusion

```{=html}
<!--
o Limitations
o Recommendations

"This study was limited by..."
-->
```
# Conclusion

# Acknowledgements

# References

::: {#refs}
:::
